# UT3.3 Gesti칩n de los recursos de un SO: La memoria

游늿 [Contenido en presentaci칩n PDF](/pdf/UT3.3 - Gesti칩n de recursos - Memoria.pdf)

## Contenido y debate introductorio

<iframe width="560" height="315" src="https://www.youtube.com/embed/jc_8k2qkSLI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## Gesti칩n de la memoria RAM

Algunos <u>conceptos</u> importantes que veremos relativos a la memoria:

-   Cada **celda** de una memoria puede almacenar un bit.
-   **Palabra**: n칰mero de bits que suele contener cada posici칩n de memoria (*6, 8,16, 32 o 64 bits*).
-   El conjunto de celdas en las que se almacena una palabra se llama **posici칩n de memoria**.
-   **Direcci칩n**: posici칩n de memoria en la que se almacena una informaci칩n (conjunto de bits que identifican a cada palabra de la memoria).
-   Hay que distinguir entre direcci칩n de una posici칩n de memoria y el dato que puede ser almacenado en esa direcci칩n.
-   Si tenemos un sistema con una palabra de 4 bits y una direcci칩n de 10 bits, tendremos una capacidad de: 2^10 (palabras)\* 4 (bits por palabra) = *4 Kbits*

En la anterior unidad vimos que el **administrador de memoria del SO** era el encargado de la gesti칩n de esta parte de un ordenador.

>   游늷 La memoria tiene que ser gestionada y controlada por el SO de tal manera que cada proceso utilice su espacio en memoria sin afectar a otros donde pudiera haber instrucciones o datos.

Generalmente la memoria se divide en:

-   **Particiones fijas:** el administrador de memoria asignar치 los procesos a las particiones de un tama침o fijo que considere. Se usar치 en la **paginaci칩n** como veremos m치s adelante.
    
-   **Particiones variables**: har치 falta una planificaci칩n m치s compleja por parte del SO para asignar los procesos de forma din치mica. Se usar치 para la **segmentaci칩n**.
    
    
<img src="media/particiones_mem.jpg" alt="particiones_mem" style="zoom:50%;" />



Al **Sistema Operativo** se le suele reservar una direcci칩n baja de memoria y a continuaci칩n el espacio de usuario con los programas divididos en particiones de tama침o predefinido o variables.

![](media/particiones_mem1.png)


La **reubicaci칩n** hace referencia al hecho de ubicar los programas en memoria para su ejecuci칩n.

El **administrador de memoria** carga procesos continuamente y los que han finalizado son eliminados de la memoria.

Cuando se utilizan particiones variables, especialmente, se da un proceso conocido como **fragmentaci칩n de la memoria**. La fragmentaci칩n es generada cuando durante el reemplazo de procesos quedan huecos entre dos o m치s procesos de manera no contigua y cada hueco no es capaz de soportar ning칰n proceso de la lista de espera.

```note
游눠 La **fragmentaci칩n** es el proceso por el cual en la memoria principal (o disco) quedan espacios o huecos sin utilizar para alg칰n proceso o dato a lo largo del tiempo, degradando el rendimiento en dichos dispositivos.
```

![](media/mem_frag.png)

Se producen dos tipos de fragmentaci칩n: **interna** y **externa**, que veremos a continuaci칩n:

-   La **fragmentaci칩n externa** ocurre cuando el primer bloque libre de memoria no es suficiente para que el siguiente programa lo use. Por ejemplo, digamos que un sistema carga tres programas en la memoria, cada uno ocupando 50 megabytes o MB. El segundo programa termina, dejando ese bloque de 50 MB libres. Si el siguiente programa a iniciar requiere de 100 MB, no ser칤a capaz de utilizar ese bloque de 50 MB de espacio libre, y el sistema le asigna el siguiente intervalo de 100 MB libres.
    
-   La **fragmentaci칩n interna** hace referencia al espacio de memoria desperdiciado dentro de las propias particiones. Por ejemplo, si el sistema carga un programa que requiere de 50 MB y 19 bytes de memoria podr칤a utilizar un bloque de 51 MB desperdiciando casi 1 MB.

> 游늷 Al proceso para revertir el estado de fragmentaci칩n en memoria o discos se le denomina **compactaci칩n**.

![](media/compactacion.png)


## Gesti칩n de la memoria virtual

Todos los ordenadores cuentan con una determinada cantidad de memoria RAM, pero esta es limitada y generalmente resulta insuficiente para los requerimientos del usuario. Fotheringam dise침칩 en 1961 un m칠todo de gesti칩n de memoria conocido como **memoria virtual.**

```note
游눠 La **memoria virtual** es una t칠cnica de gesti칩n de la memoria que permite que un sistema operativo disponga, tanto para el software de usuario como para s칤 mismo, de mayor cantidad de memoria que la que est치 disponible f칤sicamente.
```

Fotheringam pens칩 en la posibilidad de que al cargar un programa en memoria, este fuera muy grande y as칤 que cre칩 una t칠cnica de forma que solo una parte del proceso que se estaba ejecutando estar칤a en memoria, y el resto quedar칤a en los discos de almacenamiento secundario, en un sitio llamado **espacio de intercambio** como veremos m치s adelante.



![](media/esquema_memvirtual.png)

Cuando se cargan muchos procesos a la vez el ordenador se ralentiza puesto que tiene que pasar mucha informaci칩n del disco a memoria RAM y los discos de almacenamiento secundario son mucho m치s lentos que la memoria.

```note
La **MMU** (*Memory Management Unit*) es un elemento de hardware, responsable del manejo de los accesos a la memoria por parte de la CPU.
```

El papel de la **MMU** generalmente lo desempe침ar치 el chipset de la placa, siendo sus funciones:

-   Traducci칩n de direcciones l칩gicas (virtuales) a direcciones f칤sicas (reales)
-   La protecci칩n de la memoria
-   El control de la cach칠

```note
游눠 Se denomina **espacio de intercambio** a la zona de un disco de almacenamiento secundario utilizada para almacenar procesos que actualmente no est치n en ejecuci칩n y as칤 dejar memoria RAM para los procesos que s칤 lo est치n.
```

Tal y como hemos visto en la anterior unidad, la parte que administra la memoria de un SO es el **administrador de memoria.**

El administrador de memoria lleva un registro de las partes de la memoria que se est치n utilizando (en particiones) y guarda espacios para los nuevos procesos, liberando los que han finalizado. Es tambi칠n el encargado de gestionar el uso de **memoria virtual** o intercambio al disco duro en caso de necesidad.

## T칠cnicas de gesti칩n de memoria virtual

```note
游눠 Las **t칠cnicas de gesti칩n de memoria virtual** , permiten ejecutar procesos de programas de mayor tama침o que la memoria RAM disponible, usando para eso el disco de almacenamiento como ampliaci칩n de la memoria.
```

El inconveniente de esta t칠cnica es la importante bajada de rendimiento que supone el uso de discos, mucho m치s lentos que la memoria y el uso de **direcciones virtuales** y **direcciones f칤sicas** reales que necesitar치n el uso de una tabla de conversi칩n intermedia y la ayuda de la MMU.

![](media/esquema_mmu.jpg)



La gesti칩n de la **memoria virtual** se lleva a cabo mediante las cuatro t칠cnicas de gesti칩n que veremos a continuaci칩n:

1.  T칠cnica de paginaci칩n
2.  T칠cnica de segmentaci칩n
3.  T칠cnica de swapping
4.  T칠cnica de paginaci칩n segmentada


### T칠cnica de paginaci칩n

```note
游눠 La **paginaci칩n** es una t칠cnica que consiste en dividir la memoria interna o RAM en particiones iguales llamadas frames o **marcos**, y los procesos en partes del mismo tama침o denominadas **p치ginas**.
```

-   Es un esquema de gesti칩n de memoria en el que la asignaci칩n de memoria no es contigua.
-   El espacio de direcciones virtuales de un proceso est치 dividido en bloques de tama침o fijo llamados **p치ginas**.
-   Se produce fragmentaci칩n interna.
-   La memoria f칤sica se divide en **marcos de p치gina**.
-   La direcci칩n virtual consta de un n칰mero de p치gina virtual y un desplazamiento.

#### Proceso de paginaci칩n

- El espacio de direcciones virtuales divididas en bloques de tama침o fijo llamados p치ginas.
- La memoria f칤sica dividida en bloques fijos llamados **marcos de p치gina** o frames.
- Mediante una **tabla de paginas,** la CPU asigna las direcciones f칤sicas de
  los **frames** a las **paginas** en las que se ha dividido el programa.
- De la traducci칩n y asignaci칩n de direcciones en la paginaci칩n se encarga el **MMU** (*Unidad de administraci칩n de memoria*)

![esquema_paginacion1](media/esquema_paginacion1.png)


Los procesos de los distintos programas se van cargando en la memoria RAM en sus respectivos **marcos** hasta que la memoria f칤sica se llene. En ese momento los procesos que no quepan en la memoria f칤sica y no est칠n en ejecuci칩n en ese momento **se mover치n al disco** y se borrar치 su entrada de la tabla de p치ginas. 

Si al buscar una p치gina en la tabla de p치ginas no se encuentra, se producir치 un **fallo de p치gina**. Ello significa que no estaba cargada en la RAM y se solicitar치 recuperar dicho dato del disco a침adi칠ndose por tanto a la tabla una nueva entrada y borrando una anterior.

![](media/esquema_paginacion2.png)

#### Esquema de paginaci칩n

![](media/esquema_paginacion3.png)

Cuando la memoria RAM se llena se llevan los marcos de los procesos inactivos al disco duro y se eliminan de la tabla de p치ginas.

Si el dato de la direcci칩n virtual no estuviera en la tabla de p치ginas se produce un **fallo de p치gina** y se recuperar치 del espacio de intercambio del disco duro.

#### Rendimiento e hiperpaginaci칩n

```note
游눠  Si el sistema no est치 correctamente ajustado se puede producir un fen칩meno llamado **hiperpaginaci칩n o trashing**. Dicho proceso sucede cuando un proceso o programa genera fallos de p치gina frecuentemente y el sistema pasa la mayor parte del tiempo paginando degradando el rendimiento del sistema.
```

Se puede evitar reduciendo el grado de multiprogramaci칩n, es decir reduciendo el n췈 de procesos ejecutados a la vez en una m치quina con recursos limitados.

![](media/thrashing.png)

El **tama침o** de las p치ginas es otra consideraci칩n importante de cara al **rendimiento** de la t칠cnica de paginaci칩n:

- P치gina peque침a > se requieren m치s p치ginas por proceso > tablas m치s grandes > menor fragmentaci칩n interna.
- P치ginas grandes > se requieren menos p치ginas por proceso > tablas peque침as > mayor fragmentaci칩n interna.

La memoria secundaria est치 dise침ada para transferir eficientemente grandes bloques de datos, luego por todo lo anterior podr칤amos concluir que es mejor tener p치ginas m치s grandes.


### T칠cnica de segmentaci칩n

```note
游눠  La **segmentaci칩n** es una evoluci칩n del sistema anterior que se basa en el uso de particiones variables llamadas segmentos y una tabla de segmentos.
```

Si se produce un fallo de segmento se recupera del disco duro actualiz치ndose la tabla de segmentos.

Puede organizarse la memoria en **bloques** concretos y tener partes de ella
destinadas a almacenar las estructuras de datos, que pueden crecer o menguar seg칰n las necesidades del usuario o del programa.

Para ello se utilizaran las **pilas de memoria** o *stacks*, en las que gestionan las estructuras de datos necesarias.

La paginaci칩n difiere por tanto de la segmentaci칩n en que las <u>p치ginas son de tama침o fijo</u> y <u>los segmentos no</u>.

#### Esquema de segmentaci칩n

![esquema_segmentacion](media/esquema_segmentacion.png)


### T칠cnica de swapping

```note
游눠 El **swapping** es un caso concreto del uso de t칠cnicas de memoria virtual utilizado en sistemas operativos basados en **Linux,** relativa al espacio que se le da a la memoria virtual en el disco duro.
```

Se siguen usando p치ginas  y tablas de paginaci칩n en la memoria virtual y consiste en la existencia de una **partici칩n especial** , (un espacio delimitado en el disco) denominada partici칩n swap y con un tama침o generalmente que se corresponde con la mitad de la memoria RAM f칤sica total.

Se asegura de esta forma que siempre haya espacio disponible en el disco duro y se evita su fragmentaci칩n. Adem치s esta partici칩n se puede situar en un sitio del disco de m치s r치pido acceso (al principio de 칠ste) o incluso en una unidad dedicada tipo flash.

![particion_swap](media/particion_swap.jpg)

   Partici칩n de espacio swap dedicado en un SO Linux.



##   Algoritmos de sustituci칩n de p치ginas	

-  Cuando se produce un fallo de p치gina: el SO debe decidir qu칠 p치gina que est치 en memoria debe pasar a disco para traer a memoria la p치gina requerida.
-  Si la p치gina que sale ha sido modificada: se reescribe en disco.
-  Se puede elegir aleatoriamente, pero es m치s eficiente sacar una que no se vaya a utilizar pronto.
-  Algoritmos de sustituci칩n que veremos:
    -   FIFO
    -   Optimo (OPT)
    -   LRU

### Algoritmo FIFO (First Input First Output)

Es el m치s sencillo y consiste en elegir como v칤ctima la p치gina que m치s tiempo lleva en memoria. Para ello es necesario que cada p치gina posea un contador del tiempo que lleva en memoria o bien que exista una cola por orden de entrada.

![](media/algoritmo_fifo.png)

>   Partiendo de un estado inicial en que nuestras tres p치ginas est치n vac칤as, las tres primeras referencias a distintas p치ginas de memoria (7, 0, 1) causar치n fallos de p치gina. La siguiente (2) causar치 uno, pero la quinta referencia (0) puede ser satisfecha sin requerir una nueva transferencia.



### Algoritmo OPTIMO (OPT)

Consiste en reemplazar la p치gina que tardar치 m치s tiempo en utilizarse. Este algoritmo garantiza la tasa menor de fallos de p치gina, pero no es f치cilmente implementable.

![](media/algoritmo_opt.png)

> Este algoritmo, es de inter칠s casi puramente te칩rico, y tambi칠n conocido como OPT. Bajo este algoritmo, el enunciado ser치 elegir como p치gina a eliminar aquella p치gina que no vaya a ser utilizada por un tiempo m치ximo.

### Algoritmo LRU (Last Recent Used)

Consiste en reemplazar aquella p치gina que no haya sido utilizada desde hace m치s tiempo. La idea es suponer que si una p치gina lleva mucho tiempo sin utilizarse tardar치 en volver a ser utilizada. Para implementar este algoritmo, a cada p치gina se le asocia un contados que indica cuando se utiliz칩 por 칰ltima vez. Es el algoritmo m치s utilizado.

![](media/algoritmo_lru.png)

>   Cuando necesita elegir una p치gina a eliminar, LRU elige la p치gina que no ha sido empleada durante m치s tiempo. 

### Comparaci칩n FIFO vs LRU

![](media/comparacion_fifo_lru.png)



