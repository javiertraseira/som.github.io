# UT3.2 Gesti√≥n de los recursos de un SO: Los procesos

üìï [Contenido en presentaci√≥n PDF](/pdf/UT3.2 - Gesti√≥n de recursos - Procesos.pdf)

## Contenido y debate introductorio

<iframe width="560" height="315" src="https://www.youtube.com/embed/kfbmx77H2F0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

## Procesos	

```note
üí° Un **proceso** es un concepto manejado por el sistema operativo y que hace referencia a un conjunto de instrucciones de un programa en ejecuci√≥n cargado en memoria.
```

A los procesos, dependiendo del sistema operativo utilizado, se les denomina tambi√©n **flujos de control**, **tareas**, **hebras o hilos (threads)**, dependiendo del contexto.

Los sistemas operativos son los encargados de gestionar los recursos de hardware requeridos (principalmente el uso de la CPU o E/S), atendiendo a la diferentes prioridades cuando se ejecuta m√°s de un proceso de forma concurrente (en SO multitarea).

>   üìå Cuando un proceso se carga en memoria, el sistema operativo le asigna informaci√≥n en el **bloque de control de procesos (BCP)**, el cual estudiaremos m√°s adelante durante este tema.

Si trabaj√°semos con un **sistema operativo monotarea** (como *MS-DOS* en su d√≠a) la gesti√≥n de procesos ser√≠a muy sencilla: la CPU ejecutar√≠a todas las instrucciones del proceso de un programa hasta finalizar y solo en ese momento continuar√≠a con otro proceso en cola si lo hubiera.

El problema de este tipo de sistemas se hace evidente ya que mientras no finaliza la ejecuci√≥n de un programa no puede pasarse a otro desaprovechando recursos y tiempo.

En la actualidad la mayor√≠a de sistemas operativos son **multitarea**.

El sistema operativo esta hecho para no permitir a los procesos ejecutarse sino por una fracci√≥n de tiempo **muy peque√±a**, de tal forma que en un solo segundo muchos programas han tenido tiempo de procesamiento, es decir muchos procesos de distintos programas se han ejecutado en lapsos diminutos de tiempo.

```note
üí°  En un SO multitarea se aprovechan los tiempos de espera entre recursos y CPU de forma que esta se mantiene siempre trabajando. Esta t√©cnica se conoce como **multiprogramaci√≥n** y tiene como finalidad conseguir un mejor aprovechamiento de la CPU.
```


Para la resoluci√≥n de ejercicios pr√°cticos/teor√≠a usaremos un tipo de diagramas ampliamente utilizado en inform√°tica denominados **diagramas de Gantt.**

>   üìå Un **diagrama de Gantt** es una representaci√≥n gr√°fica para representar el tiempo de dedicaci√≥n previsto para diferentes tareas o procesos a lo largo de un tiempo total determinado.


![diagrama_gantt](media/diagrama_gantt.png)

Diagrama de Gantt de la ejecuci√≥n de dos procesos **P1** y **P2** en un SO monotarea. El tiempo **t** en este tipo de diagramas se mide en **ciclos de procesador**.

```note
üí° Se denomina **hebra** o **hilo** a un punto de ejecuci√≥n cualquiera en un proceso. Un proceso tendr√° siempre una hebra, en la que corre el propio programa, pero puede tener m√°s hebras.
```

Un proceso cl√°sico es aquel que solo posee una **hebra**.

[^1]: Si por ejemplo ejecutamos un procesador de textos como Word, con un solo documento abierto, el programa Word convertido en proceso estar√° ejecut√°ndose en un √∫nico espacio de memoria (con acceso a archivos, galer√≠as de im√°genes, corrector ortogr√°fico..). Este proceso, de momento, tendr√° una hebra. Si en esta situaci√≥n, sin cerrar Word abrimos un nuevo documento, Word no se volver√° a cargar como proceso. Simplemente el programa, convertido en proceso, tendr√° a su disposici√≥n **dos hebras **o hilos diferentes, de tal forma que el proceso sigue siendo el mismo (el original). Word se est√° ejecutando una sola vez y el resto de documentos de texto que abramos ser√°n hilos o hebras del proceso principal, que es el propio procesador de textos.

![hebras_hilos](media/hebras_hilos.png)

## Estados y transiciones de los procesos	

Existen **tres estados** para los procesos (o hilos correspondientes):

-   **En ejecuci√≥n:** El procesador est√° ejecutando instrucciones del proceso
    cargado en ese momento (tiene su atenci√≥n y prioridad)

-   **Preparado, en espera o activo:** El proceso est√° preparado para ser
    ejecutado y esperando su turno para ser atendido por la CPU.
    
-   **Bloqueado:** El proceso ha entrado en un estado de bloqueo que puede
    darse por causas m√∫ltiples (acceso a un mismo fichero, errores..)
    
    [^2]: En algunas biograf√≠as pueden utilizarse tambi√©n los estados **nuevo** y **terminado** .
    
    

------

Una vez que un programa se ha lanzado y se ha convertido en proceso, puede atravesar varias fases o **estados** hasta que termina.

![](media/transiciones.jpg)

Los cambios de estado en los que se puede encontrar un proceso es lo que se denomina **transiciones**:

- **Transici√≥n A**. Ocurre porque el proceso que est√° en ejecuci√≥n necesita alg√∫n elemento, se√±al, dato, para poder continuar ejecut√°ndose.

- **Transici√≥n B**. Ocurre cuando un proceso ha utilizado el tiempo asignado por la CPU y deja paso al siguiente proceso.

- **Transici√≥n C**. Ocurre cuando el proceso que est√° preparado pasa a estado de ejecuci√≥n en la CPU. 

- **Transici√≥n D**. Ocurre cuando el proceso pasa a preparado, es decir, al recite la orden o se√±al que estaba esperando en estado de bloqueado.

![estados_procesos](media/estados_procesos.png)

En el siguiente diagrama observamos tres procesos (*o hilos*) pasando de estado de ejecuci√≥n a quedar en espera o bloqueados:

![diagrama_procesos](media/diagrama_procesos.jpg)

Del que un proceso cambie de estado en un momento u otro se encarga el **planificador de procesos del sistema operativo.**

```note
üí° El **planificador** de un sistema operativo se encarga de asignar **prioridades** a los diferentes procesos para llevar a cabo su ejecuci√≥n en el menor tiempo y de la forma m√°s √≥ptima posible.
```

Mediante t√©cnicas que veremos a continuaci√≥n, se consigue indicar a la CPU del ordenador que procesos deben ejecutarse en qu√© momento concreto y los diferentes estados que deben ir adoptando. Ello se lleva cabo mediante **algoritmos de planificaci√≥n**.

Como hemos visto, cualquier proceso, pasar√° por diferentes estados y el cambio de un estado a otro no es trivial y tanto la forma como el tiempo para hacerlo marcar√°n la eficiencia del sistema. 

```note
Un **cambio de contexto** consiste en interrumpir la ejecuci√≥n de un proceso para comenzar o seguir con otro.
```

![cambio_contexto](media/cambio_contexto.png)


## Bloque de control de procesos	

```note
üí° La informaci√≥n de un proceso que el sistema operativo necesita para controlarlo se  guarda en un **bloque de control de procesos o BCP**. 
```

En el **BCP** cada proceso almacena informaci√≥n como:

- Nombre del proceso
- **Identificador del nombre e identificador del proceso**. A cada proceso se le asigna un identificador denominado **PID**. Si tiene un proceso padre se identificar√° a su vez con su **PPID**.
- **Estado actual del proceso**: Ejecuci√≥n, preparado o bloqueado.
- **Prioridad del proceso**. Se la asigna el planificador o el usuario de forma manual.
- **Ubicaci√≥n y tama√±o usado en memoria**. Direcci√≥n de memoria en la que est√° cargado el proceso y espacio utilizado.  
- **Recursos utilizados**. Otros recursos hardware y software para poder ejecutarse.


| BCP b√°sico de un proceso |
| ------------------------ |
| Nombre del proceso       |
| PID del proceso y PPID   |
| Estado del proceso       |
| Prioridad del proceso    |
| Ubicaci√≥n en memoria     |
| Tama√±o en memoria        |
| Recursos                 |



## Algoritmos de planificaci√≥n

```note
üí° Un **algoritmo** es una serie ordenada de instrucciones o pasos o que llevan a la soluci√≥n de un determinado problema.
```

Los hay tan sencillos y cotidianos como seguir la receta del m√©dico, abrir una puerta, lavarse las manos, etc; hasta los que conducen a la soluci√≥n de problemas muy complejos.

1.  Tomar el cepillo de dientes
2.  Aplicar crema dental al cepillo
3.  Abrir el grifo
4.  Remojar el cepillo con la crema dental
5.  Cerrar el grifo
6.  Frotar los dientes con el cepillo
7.  Abrir el grifo
8.  Enjuagarse la boca
9.  Enjuagar el cepillo
10. Cerrar el grifo

    
Gracias a los **algoritmos de planificaci√≥n** usados en SO multiproceso, la CPU se encarga de asignar tiempos de ejecuci√≥n a cada proceso seg√∫n el tipo de algoritmo y la prioridad de cada proceso.

El objetivo de un algoritmo de planificaci√≥n es decidir qu√© proceso se ejecuta en cada momento en la CPU de un SO multitarea.

Dichos algoritmos pueden ser de <u>dos tipos</u>:

-   **Apropiativos**: un proceso puede ser interrumpido por otro para dejarle acabar.
-   **No apropiativos**: una vez un proceso entra en la CPU no se libera hasta terminar. 

Los algoritmos de planificaci√≥n usados en SO actuales que veremos son:
-   **Algoritmo FIFO** (*First Input First Output*)
-   **Algoritmo SJF** (*Shortest Job First*)
-   **Algoritmo de rueda** (*Round Robin*)
-   **Algoritmo basado en prioridad**


### Algoritmo FIFO

Para este algoritmo denominado **FIFO** (*First Input, First Output*), *el primero que entra es el que sale*. El procesador ejecuta cada proceso hasta que finaliza, por tanto, los procesos llegar√° a una cola de procesos a esperar en orden a que les llegue su turno.

Se trata de una pol√≠tica muy simple y sencilla de llevar a la pr√°ctica, pero de rendimiento pobre.

La cantidad de tiempo de espera de cada proceso depende del n√∫mero de procesos que haya antes en cola de espera. Sus caracter√≠sticas son:

-   **No apropiativo** (**La CPU no se libera hasta haber terminado**)
-   Es justo, aunque los procesos largos hacen esperar mucho a los cortos.
-   El tiempo medio de servicio es muy variable en funci√≥n del n√∫mero de
    procesos y su duraci√≥n.

Video explicativo en Youtube:

<iframe width="560" height="315" src="https://www.youtube.com/embed/Hva8nI8jsc4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Algoritmo SJF

El algoritmo **SJF** (*Shortest Job First* ) que viene de ‚Äòel trabajo m√°s corto primero‚Äô. Se trata de un algoritmo que supone que los tiempos de ejecuci√≥n ya se conocen de antemano, algo que no siempre es posible saber.
Cuando hay varios trabajos de igual importancia esperando a ser iniciados en la cola de entrada, el planificador seleccionar√° el trabajo m√°s corto primero.

Sus caracter√≠sticas son:

-  No apropiativo.
-  Muy complicado de implementar, necesario predecir los tiempo de ejecuci√≥n de los procesos con antelaci√≥n.
-  Se considera relativamente √≥ptimo.

Video explicativo en Youtube:

<iframe width="560" height="315" src="https://www.youtube.com/embed/uiQ1FHtnL_E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Algoritmo RR (rueda)

El algoritmo **RR** (*Round Robin*) o de la rueda es uno de los algoritmos m√°s sencillos y utilizados en sistemas Windows y Linux. En su utilizaci√≥n no se establecen prioridades (siendo apropiativo). Cada proceso tiene asignado un tiempo de ejecuci√≥n denominado **quantum (Q)**. Si se cumple ese tiempo y la tarea no ha concluido, se da paso al siguiente proceso y el proceso no finalizado pasa al final de la lista de procesos en espera.

Sus caracter√≠sticas son:

-   Apropiativo
-   Es un algoritmo **justo** (evita la monopolizaci√≥n de la CPU)
-   Su rendimiento depende del valor de **Q**
-   Usa FIFO para la gesti√≥n de la cola de procesos.

El *quantum* **Q** suele definirse entre unos *20ms*o *50ms*


>   Tal y como se muestra en la figura, si se est√° ejecutando el *proceso 1*y se agota su cantidad de **quantum Q**, se desalojar√≠a la CPU y pasar√≠a a ejecutarse el *proceso 2*. Cuando termine el quantum del *proceso 10* se pasar√° de nuevo al *proceso 1*. Se usa **FIFO** a la hora de pasar de un proceso a otro en la cola.

![RR](media/RR.jpg)

Video explicativo en Youtube:

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZNPFx-kVbjU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

### Algoritmo basado en prioridad

Otro tipos de algoritmos usados en SO modernos son los basados en **prioridades**. En ellos se asocia una prioridad a cada proceso y la CPU se asigna al trabajo con prioridad m√°s alta en cada momento.

Normalmente, si se est√° ejecutando un proceso de prioridad media y entra un proceso de prioridad mayor, se requisa la CPU al primer proceso y se le entrega al proceso de mayor prioridad.

Video explicativo en Youtube:

<iframe width="560" height="315" src="https://www.youtube.com/embed/BxjI8jM94Ss" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>


### Ejemplos de algoritmos

Algunos **conceptos** importantes que usaremos a la hora de completar las tablas de los problemas de los diferentes algoritmos de planificaci√≥n:

- **Ciclo de llegada:** Momento en el que llega un proceso al planificador de procesos del SO.
- **Ciclos de ejecuci√≥n**: Ciclos de CPU que consume un proceso mientras se encuentra en estado de ejecuci√≥n
- **Tiempo de espera**: Tiempo que un proceso est√° esperando en la cola de procesos preparados o listos.
- **Tiempo de retorno**: Tiempo que transcurre desde que un proceso llega, hasta que sale (tiempo que tarda en ejecutarse)

  

- Representa en forma de diagrama de Gantt del **algoritmo FIFO** para la siguiente lista de 5 procesos (*A,B,C,D,E*): 

![](media/Problema1.png)

- Representa en forma de diagrama de Gantt del **algoritmo SJF** para la siguiente lista de 5 procesos (A,B,C,D,E): 

![](media/Problema2.png)

- Representa en forma de diagrama de Gantt del **algoritmo RR con q**=**2** para la siguiente lista de 5 procesos (A,B,C,D,E):

![Problema3](media/Problema3.png)

- Representa en forma de diagrama de Gantt del **algoritmo de Prioridad** para la siguiente lista de 5 procesos (A,B,C,D,E): 

![Problema4](media/Problema4.png)


## Interrupciones y excepciones

```note
üí° Una **interrupci√≥n** es una se√±al que obliga al SO a tomar el control del procesador para estudiarla y tratarla.
```

Una interrupci√≥n es un mecanismo que permite ejecutar un bloque de instrucciones interrumpiendo la ejecuci√≥n normal de un programa, y luego intentar restablecer la ejecuci√≥n del mismo sin afectarlo directamente. De este modo un programa puede ser interrumpido temporalmente para atender alguna necesidad urgente del computador y luego continuar su ejecuci√≥n como si nada hubiera pasado. Algunos tipos de interrupciones **no son recuperables**.

Existen varios tipos de interrupciones:

- Interrupciones de hardware 
- Interrupciones de software. 
- Excepciones. 

<img src="media/interrupciones_so.png" alt="interrupciones_so" style="zoom:80%;" />

### Interrupciones de hardware y software

Existen varios tipos de interrupciones, dependiendo de d√≥nde se produzcan dichos eventos para ser atendidos:

- **De hardware**, un dispositivo (hardware) requiere la atenci√≥n de la CPU para ejecutar su driver.
- **De I/O**, provocadas por los dispositivos de I/O.
- **Externas**, provocadas por elementos hardware del ordenador.
- **De reinicio** (inesperadas), del sistema, pulsar tecla reinicio‚Ä¶
- **De Software**, se producen como consecuencia directa de los procesos en ejecuci√≥n.
- **Llamadas al Sistema,** invocaci√≥n de una instrucci√≥n del sistema.

Cuando se produce una interrupci√≥n se pasa el control al sistema operativo, quien salva el contexto del proceso que se estaba ejecutando y se analiza la interrupci√≥n. Las interrupciones est√°n catalogadas y el sistema operativo dispone de rutinas especiales para manipular cada tipo de interrupci√≥n. Una vez se ha atendido la interrupci√≥n la CPU contin√∫a con su anterior tarea.

<img src="media/interrupcion.png" alt="interrupcion" style="zoom:67%;" />


### Excepciones

```note
üí° Una **excepci√≥n** es un tipo de interrupci√≥n provocada por la propia CPU a causa de un error en la ejecuci√≥n del proceso en activo como puede ser la realizaci√≥n de operaciones no permitidas, c√≥digos de operaci√≥n mal expresados, direcciones de memoria fuera de rango, etc.
```

Es el proceso o el proprio programa el que intenta llevar a cabo el manejo y control de dicho error.

El tratamiento de una excepci√≥n es similar al de la interrupci√≥n, con la salvedad de que las excepciones, a menudo, no contin√∫an el proceso con fallo sino que lo abortan.

<img src="media/exception.png" alt="exception" style="zoom:50%;" />


### Comparativa entre interrupciones y excepciones



|                      **Interrupciones**                      |                       **Excepciones**                        |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| Las interrupciones se presentan inesperadamente y sin relaci√≥n con el proceso en ejecuci√≥n. Son parte intr√≠nseca del funcionamiento de cualquier sistema. | Las excepciones se producen como efecto directo de una instrucci√≥n concreta del proceso que se esta ejecutando. Aparecen por defectos de programaci√≥n y errores graves. |
| El SO atiende la interrupci√≥n y a continuaci√≥n contin√∫a con al ejecuci√≥n del proceso con la que estaba. | Son errores no recuperables. |
| Las interrupciones suelen tener asociados niveles de prioridad para su tratamiento. | Las excepciones no tienen asociados niveles de prioridad para su tratamiento. |
| Si se producen varias interrupciones simult√°neamente, s√≥lo se tratar√° una, quedando bloqueadas el resto. |          Las excepciones se producen de una en una.          |





