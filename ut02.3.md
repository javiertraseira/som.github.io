# UT2.3 Gesti칩n de los recursos de un SO: La memoria

## La memoria

### Memoria principal interna

La **memoria interna principal** son chips conectados a la placa base principal de cualquier ordenador o computadora. Son dispositivos caros y r치pidos que almacenan informaci칩n para la operaciones y el procesamiento de los datos de la CPU, gr치fica y el sistema operativo.

![](media/fb61e84bca137588101d62706398ef8b.jpeg)![](media/2903907301ca0c30dd0f2e63a9ee895c.png)

La memoria **RAM** se utiliza para el almacenamiento y la recuperaci칩n inmediata de datos. Su memoria RAM puede procesar la informaci칩n significativamente m치s r치pido que los datos de un disco duro: de veinte a cien veces m치s r치pido, dependiendo del hardware y la tarea espec칤ficos.

La memoria **ROM** hace referencia a un peque침o espacio de memoria para almacenar el firmware de un ordenador o dispositivo.

쮺u치nta **memoria RAM** requieren las siguientes aplicaciones?

![](media/e778a352bd23e8bed8ad7f9e4c897a2f.jpeg)

### Esquema de memorias

![](media/esquema.png)

## Gesti칩n de la memoria RAM

Algunos **conceptos** importantes que veremos relativos a la memoria:

-   Cada **celda** de una memoria puede almacenar un bit.
-   **Palabra**: n칰mero de bits que suele contener cada posici칩n de memoria (6, 8, 16, 32 o 64 bits).
-   El conjunto de celdas en las que se almacena una palabra se llama **posici칩n de memoria**.
-   **Direcci칩n**: posici칩n de memoria en la que se almacena una informaci칩n (conjunto de bits que identifican a cada palabra de la memoria).
-   Hay que distinguir entre direcci칩n de una posici칩n de memoria y el dato que puede ser almacenado en esa direcci칩n.
-   Si tenemos un sistema con una palabra de 4 bits y una direcci칩n de 10 bits, tendremos una capacidad de: 210 (palabras) \* 4 (bits por palabra) = 4 Kbits

![ ](media/ed1b92300e057fd76fcec95b602b9f90.png)

```note
La **gesti칩n de memoria** de los sistemas operativos (a trav칠s del administrador de memoria) es el proceso de administrar el uso de la memoria principal por parte de los distintos procesos que se ejecutan en un sistema inform치tico.
```

La gesti칩n de memoria tiene como objetivos principales:

-   Asignar espacio en memoria a los procesos cuando lo necesiten y liberarlo cuando terminen.
-   Proteger los espacios de memoria de los procesos para evitar interferencias o accesos no autorizados.
-   Compartir la memoria entre los procesos que lo requieran, por ejemplo, para comunicarse o acceder a datos comunes.
-   Optimizar el rendimiento del sistema, aprovechando al m치ximo la capacidad de la memoria y reduciendo el tiempo de acceso.

Existen dos formas principalmente para gestionar la memoria, dependiendo del tipo de sistema operativo, el hardware disponible y las necesidades de los usuarios.

Las t칠cnicas que veremos son:

-   **Particionado:** se divide la memoria en particiones fijas o variables. A cada partici칩n se asigna a un proceso, y se utiliza una tabla para llevar el control de las particiones libres y ocupadas.Provoca fragmentaci칩n en la memoria, que veremos a posteriori.

![](media/3b8ae776d53bc0579b994ccdd0d5c63b.jpeg)

-   **Paginaci칩n**: se divide la memoria en unidades peque침as y fijas llamadas **p치ginas**, y se divide cada proceso en unidades del mismo tama침o llamadas **marcos**. Se usa tambi칠n una tabla para asignar los marcos a las p치ginas. La paginaci칩n permite que los procesos se ejecuten de manera eficiente sin preocuparse por la ubicaci칩n f칤sica de los datos en memoria.
![](media/ff6f7ca48cd660df172b2946a249fa70.jpeg)

El administrador de memoria carga procesos continuamente y los que han finalizado son eliminados de la memoria.

Cuando se utilizan particiones variables, especialmente, se da un proceso conocido como **fragmentaci칩n de la memoria**. La fragmentaci칩n es generada cuando durante el reemplazo de procesos quedan huecos entre dos o m치s procesos de manera no contigua y cada hueco no es capaz de soportar ning칰n proceso de la lista de espera.

> La **fragmentaci칩n** es el proceso por el cual en la memoria principal (o disco) quedan espacios o huecos sin utilizar para alg칰n proceso o dato a lo largo del tiempo, degradando el rendimiento en dichos dispositivos.


![](media/eebf0836eb3e5893b82b44ad46ff3972.png)**Memoria interna en estado de fragmentaci칩n**

En la memoria producen dos tipos de fragmentaci칩n:

-   La **fragmentaci칩n interna** hace referencia al espacio de memoria desperdiciado dentro de las propias particiones.

    Por ejemplo, si el sistema carga un programa que requiere de 50 MB y 19 bytes de memoria podr칤a utilizar un bloque de 51 MB desperdiciando casi 1 MB.


-   La **fragmentaci칩n externa** ocurre cuando el primer bloque libre de memoria no es suficiente para que el siguiente programa lo use.

    Por ejemplo, digamos que un sistema carga tres programas en la memoria, cada uno ocupando 50 megabytes o MB. El segundo programa termina, dejando ese bloque de 50 MB libres. Si el siguiente programa a iniciar requiere de 100 MB, no ser칤a capaz de utilizar ese bloque de 50 MB de espacio libre, y el sistema le asigna el siguiente intervalo de 100 MB libres.



![](media/675ed88dc4c4443119dfb0e94357d772.jpeg)


### Particiones 

El administrador divide la memoria en particiones de varios tama침os antes del inicio de la ejecuci칩n de los programas. 

Cuando llega un nuevo proceso, el planificador lo ubica en la partici칩n con el tama침o m치s adecuado y, cuando un proceso acaba, su partici칩n queda libre para un nuevo uso.

Este m칠todo genera **fragmentaci칩n interna** y **fragmentaci칩n externa** ya que no siempre se aprovecha todo el espacio de memoria.

![ ](media/partitions1.png) 


### Paginaci칩n

Se divide la memoria en unidades peque침as y fijas llamadas **p치ginas**, y se divide cada proceso en unidades del mismo tama침o llamadas **marcos**. 

Cada marco se asigna a una p치gina libre en memoria (que no tiene por qu칠 ser contigua), y se utiliza una tabla para llevar el control de las p치ginas y los marcos. 

Esta t칠cnica evita la *fragmentaci칩n externa*, pero puede generar sobrecarga por el manejo de las tablas y los cambios de p치gina. El 칰ltimo marco genera **fragmentaci칩n interna**.


![](media/6c7874998f864ba974d59436e8bdf31a.png)


- A modo de ejemplo, imagina que el proceso que queremos cargar en memoria lo represent치ramos con el zumo contenido en la botella de la siguiente imagen. Por su parte, la memoria donde pretendemos almacenarlo estar칤a representada por los vasos. Cada vaso, ser칤a el equivalente a un marco de p치gina de la memoria.

![](media/6ea9cc9120300947a2923ae0c793dd40.jpeg)

- As칤, cuando carguemos el proceso en memoria, cada p치gina (cantidad de zumo del tama침o de un vaso) se ubicar치 en un marco de p치gina diferente. Gracias a este planteamiento, se acaba con la fragmentaci칩n externa, y la fragmentaci칩n interna quedar치 reducida al 칰ltimo marco de p치gina asignado a cada proceso.

![](media/94095632429f2ed6cb624192c1b8af3c.jpeg)

## Gesti칩n de la memoria virtual

Todos los ordenadores cuentan con una determinada cantidad de memoria RAM, pero esta es limitada y generalmente resulta insuficiente para los requerimientos del usuario. Fotheringam dise침칩 en 1961 un m칠todo de gesti칩n de memoria conocido como **memoria virtual.**

```note
游눠 La **memoria virtual** es una t칠cnica de gesti칩n de la memoria que permite que un sistema operativo disponga, tanto para el software de usuario como para s칤 mismo, de mayor cantidad de memoria que la que est치 disponible f칤sicamente.
```

Fotheringam pens칩 en la posibilidad de que al cargar un programa en memoria, este fuera muy grande y as칤 que cre칩 una t칠cnica de forma que solo una parte del proceso que se estaba ejecutando estar칤a en memoria, y el resto quedar칤a en los discos de almacenamiento secundario, en un sitio llamado **espacio de intercambio** como veremos m치s adelante.

![](media/esquema_memvirtual.png)

> Cuando se cargan muchos procesos a la vez el equipo se ralentiza puesto que tiene que pasar mucha informaci칩n del disco a memoria RAM y los sistemas de almacenamiento secundario son mucho m치s lentos que la memoria.


```note
游눠 Se denomina **espacio de intercambio** a la zona de un disco de almacenamiento secundario utilizada para almacenar procesos que actualmente no est치n en ejecuci칩n y as칤 dejar memoria RAM para los procesos que s칤 lo est치n.
```

Tal y como hemos visto en la anterior unidad, la parte que administra la memoria de un SO es el **administrador de memoria.**

El administrador de memoria lleva un registro de las partes de la memoria que se est치n utilizando (en particiones) y guarda espacios para los nuevos procesos, liberando los que han finalizado. Es tambi칠n el encargado de gestionar el uso de **memoria virtual** o intercambio al disco duro en caso de necesidad.

```note
游눠 Las **t칠cnicas de gesti칩n de memoria virtual** , permiten ejecutar procesos de programas de mayor tama침o que la memoria RAM disponible, usando para eso el disco de almacenamiento como ampliaci칩n de la memoria.
```

El inconveniente de esta t칠cnica es la importante bajada de rendimiento que supone el uso de discos, mucho m치s lentos que la memoria y el uso de **direcciones virtuales** y **direcciones f칤sicas** reales que necesitar치n el uso de una tabla de conversi칩n intermedia que veremos m치s adelante.

![](media/esquema_mmu.jpg)


## T칠cnicas de gesti칩n de la memoria virtual 

### Paginaci칩n con memoria virtual

Recordemos que la paginaci칩n es una t칠cnica que consiste en dividir la memoria interna o RAM en particiones iguales llamadas frames o marcos, y los procesos en partes del mismo tama침o denominadas p치ginas. 

-   Es un esquema de gesti칩n de memoria en el que la asignaci칩n de memoria no es contigua.
-   El espacio de direcciones virtuales de un proceso est치 dividido en bloques de tama침o fijo llamados **p치ginas**.
-   Se produce algo de fragmentaci칩n interna.
-   La memoria f칤sica se divide en **marcos de p치gina**.

Se utiliza habitualmente para la gesti칩n de la memoria virtual gracias a su facilidad para llevar p치ginas no usadas al disco.

- El espacio de direcciones virtuales divididas en bloques de tama침o fijo llamados p치ginas.
- La memoria f칤sica dividida en bloques fijos llamados **marcos de p치gina** o frames.
- Mediante una **tabla de paginas,** la CPU asigna las direcciones f칤sicas de
  los **frames** a las **paginas** en las que se ha dividido el programa.
- De la traducci칩n y asignaci칩n de direcciones en la paginaci칩n se encarga el **MMU** (*Unidad de administraci칩n de memoria*)

![esquema_paginacion1](media/esquema_paginacion1.png)


Los procesos de los distintos programas se van cargando en la memoria RAM en sus respectivos **marcos** hasta que la memoria f칤sica se llene. En ese momento los procesos que no quepan en la memoria f칤sica y no est칠n en ejecuci칩n en ese momento **se mover치n al disco** y se borrar치 su entrada de la tabla de p치ginas. 

Si al buscar una p치gina en la tabla de p치ginas no se encuentra, se producir치 un **fallo de p치gina**. Ello significa que no estaba cargada en la RAM y se solicitar치 recuperar dicho dato del disco a침adi칠ndose por tanto a la tabla una nueva entrada y borrando una anterior.

![](media/esquema_paginacion2.png)

![](media/esquema_paginacion3.png)

Cuando la memoria RAM se llena se llevan los marcos de los procesos inactivos al disco duro y se eliminan de la tabla de p치ginas.

Si el dato de la direcci칩n virtual no estuviera en la tabla de p치ginas se produce un **fallo de p치gina** y se recuperar치 del espacio de intercambio del disco duro.

#### Rendimiento paginaci칩n (hiperpaginaci칩n)

```note
游눠  Si el sistema no est치 correctamente ajustado se puede producir un fen칩meno llamado **hiperpaginaci칩n o trashing**. Dicho proceso sucede cuando un proceso o programa genera fallos de p치gina frecuentemente y el sistema pasa la mayor parte del tiempo paginando degradando el rendimiento del sistema.
```

Se puede evitar reduciendo el grado de multiprogramaci칩n, es decir reduciendo el n췈 de procesos ejecutados a la vez en una m치quina con recursos limitados.

![](media/thrashing.png)

El **tama침o** de las p치ginas es otra consideraci칩n importante de cara al **rendimiento** de la t칠cnica de paginaci칩n:

- P치gina peque침a > se requieren m치s p치ginas por proceso > tablas m치s grandes > menor fragmentaci칩n interna.
- P치ginas grandes > se requieren menos p치ginas por proceso > tablas peque침as > mayor fragmentaci칩n interna.

La memoria secundaria est치 dise침ada para transferir eficientemente grandes bloques de datos, luego por todo lo anterior podr칤amos concluir que es mejor tener p치ginas m치s grandes.


### T칠cnica de swapping

```note
游눠 El **swapping** es un caso concreto del uso de t칠cnicas de memoria virtual utilizado en sistemas operativos basados en **Linux,** relativa al espacio que se le da a la memoria virtual en el disco duro.
```

Se siguen usando p치ginas  y tablas de paginaci칩n en la memoria virtual y consiste en la existencia de una **partici칩n especial** , (un espacio delimitado en el disco) denominada partici칩n swap y con un tama침o generalmente que se corresponde con la mitad de la memoria RAM f칤sica total.

Se asegura de esta forma que siempre haya espacio disponible en el disco duro y se evita su fragmentaci칩n. Adem치s esta partici칩n se puede situar en un sitio del disco de m치s r치pido acceso (al principio de 칠ste) o incluso en una unidad dedicada tipo flash.

![particion_swap](media/particion_swap.jpg)

   Partici칩n de espacio swap dedicado en un SO Linux.



