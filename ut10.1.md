# UT10.1: Operaciones generales en sistemas Linux

## Operaciones b√°sicas en consola

```note
El int√©rprete de comandos, **consola** o shell, es la interfaz entre el usuario y el sistema operativo.
```

El **shell**, es tanto un interprete de comandos como un lenguaje de programaci√≥n interactivo. Cuando un usuario se conecta al sistema, se inicia autom√°ticamente **/etc/passwd.**

Los tipos de shell en SO Linux m√°s comunes son:

- *sh ("Bourne shell")*
- **bash("Bourne again shell")**
- *csh ("C Shell")*
- *tcsh ("Tenex C shell")*
- *ksh ("Korn shell")*
- *zsh ("Zero shell")*

üí° Ubuntu utiliza por **defecto el shell bash**.

Es posible cambiar el shell durante una sesi√≥n; bastar√° con ejecutar el archivo ejecutable correspondiente. Por ejemplo: */bin/bash*

![](media/9725a9e9bce90712b18743826c9e45b0.png)

Las principales <u>caracter√≠sticas</u> del int√©rprete GNU Bash son:

-   Control del entorno de los procesos.
-   Ejecuci√≥n s√≠ncrona de √≥rdenes (una tras otra) o as√≠ncrona (en paralelo).
-   Distintos tipos de redirecciones de entradas y salidas para el control y filtrado de la informaci√≥n.
-   Ejecuci√≥n de mandatos interactiva y desatendida, aceptando entradas desde teclado o desde ficheros.
-   Proporciona una serie de √≥rdenes internas para la manipulaci√≥n directa del int√©rprete y su entrono de operaci√≥n.
-   Un lenguaje de programaci√≥n de alto nivel, que incluye distinto tipos de variables, operadores, matrices, estructuras de control de flujo, entrecomillado, sustituci√≥n de valores y funciones.
-   Control de trabajos en primer y segundo plano.
-   Edici√≥n del hist√≥rico de comandos ejecutados.
-   Posibilidad de usar una "shell" para el uso de un entorno controlado

```note
Se llama **prompt** al car√°cter o conjunto de caracteres que se muestran en la l√≠nea de comandos de la terminal para indicar que est√° a la espera de √≥rdenes.
```

El *prompt* de la terminal de Ubuntu tiene el siguiente aspecto por defecto:

![](media/722d3695709c2d120a62cac79a47433e.png)

Est√° compuesto por:

-   El nombre de usuario "javi"
-   El s√≠mbolo de "**@**"
-   Nombre del equipo "javi-VirtualBox"
-   Dos puntos "**:**"
-   Directorio donde nos encontramos "\~" *(si lo omite es que es el home por defecto)*
-   S√≠mbolo del dolar "**\$**" (si estamos como **root** cambiar√° a "\#").

Algunas **combinaciones** de teclado interesantes para usar en la terminal:

| **Comando**           | **Acci√≥n**                              |
|-----------------------|-----------------------------------------|
| Ctrl + Alt + Fn (1-6) | Abrir terminales a pantalla completa    |
| **tty**               | Indica el n¬∫ de terminal actual abierto |
| Tab (tabulador)       | Autocompletado (funci√≥n de expansion)   |
| Flecha arriba / abajo | Moverse por el historial de comandos    |
| **clear**             | Limpiar pantalla de la consola          |
| **history**           | Historial de comandos                   |
| Ctrl + r              | Buscar comando en el historial          |
| Ctrl + c              | Interrumpir proceso actual              |
| **!!**                | Repetir √∫ltimo comando utilizado        |
| **exit**              | Cerrar terminal                         |

**Comandos b√°sicos** de utilizaci√≥n en la consola/terminal de Linux:

| **Comando** | **Acci√≥n**                                                    | **Ejemplo**             |
|-------------|---------------------------------------------------------------|-------------------------|
| **pwd**     | Muestra el directorio actual                                  | pwd                     |
| **ls**      | Lista ficheros y directorios                                  | ls -l                   |
| **cd**      | Cambia de directorio                                          | cd mp3/wim_mertens      |
| **mkdir**   | Crea uno o varios directorios                                 | mkdir cartas facturas   |
| **cat**     | Visualiza un fichero                                          | cat /var/log/dmesg      |
| **more**    | Visualiza un fichero pantalla a pantalla                      | more /var/log/dmesg     |
| **less**    | Visualiza un fichero pantalla a pantalla y permite retroceder | less /var/log/dmesg     |
| **head**    | Visualiza las primeras filas de un fichero                    | head -n5 /var/log/dmesg |
| **tail**    | Visualiza las √∫ltimas filas de un fichero                     | tail /var/log/dmesg     |
| **touch**   | Crea un fichero vac√≠o                                         | touch listado.txt       |
| **nano**    | Editor de textos simple                                       | nano listado.txt        |
| **vi**      | Editor de textos muy potente                                  | vi listado.txt          |
| **apt**     | Instala y desinstala programas y aplicaciones en Ubuntu       | apt-get install mc      |
| **man**     | Muestra ayuda sobre un determinado comando                    | man ls                  |
| **history** | Muestra el historial de comandos utilizados                   | history                 |
| **env**     | Mostrar la lista de variables de entorno                      | env                     |

Significado de los **colores** para el comando **ls** en la terminal bash de Ubuntu:

![](media/e6493354d7da9285047e8040d59b2576.png)

El historial de comandos escritos se visualiza usando el comando **history**.

Este historial se guarda dentro del fichero **.bash_history** dentro de nuestra carpeta personal de usuario.

![](media/55c4b84f50c5578e0054babe224cc69e.jpeg)

El comando **history**, por defecto, tiene algunas limitaciones; de *500 a 1000* entradas por usuario. Otro problema es que si tenemos m√∫ltiples ventanas de consola abiertas s√≥lo guardar√° informaci√≥n de la primera.

Los par√°metros del comando est√°n ubicados en el fichero **.bashrc**, que se pueden modificar de manera f√°cil, veamos un ejemplo.

## Variables de entorno

```note
Las **variables de entorno** son porciones de memoria que guardan datos.
```

En la terminal Bash las variables de entorno tienen un nombre alfanum√©rico. 

üí°Para referirse al valor de la variable se utiliza el car√°cter d√≥lar \$ como prefijo del nombre.

Para ver las variables se usa el comando **env**. Algunas de las importantes son:

| **Variable** | **Descripci√≥n**                                                               |
|--------------|-------------------------------------------------------------------------------|
| \$HOME       | Directorio personal del usuario actual.                                       |
| \$HOSTNAME   | Nombre de la m√°quina.                                                         |
| \$PATH       | Lista de directorios donde buscar los programas ejecutables (separados por ;) |
| \$SHELL      | Int√©rprete de comandos por defecto.                                           |
| \$TERM       | Tipo de terminal.                                                             |
| \$USER       | Nombre del usuario.                                                           |
| \$PWD        | Ruta del usuario actual.                                                      |
| \$PS1        | PROMPT principal                                                              |

Se pueden cambiar el valor de las variables seg√∫n necesidad o a√±adir variables propias para que sean utilizadas por otros programas o desde la l√≠nea de comando.

Por ejemplo para crear una nueva variable: HOY=viernes

Se podr√° ver el valor de esa variable escribiendo: echo \$HOY *(no olvidar el \$ delante)*

Si ahora se empleara el comando **set** la variable aparecer√° ah√≠, sin embargo usando el comando **env** no aparecer√°. La variable ha sido creada localmente y solo podr√° ser referenciada localmente.

Para que sea accesible por subrutinas o procesos hijos se deber√° utilizar el comando

**export** que har√° que pase de ser local a ser una variable del entorno: **export** HOY

Para que el valor sea permanente debes a√±adir la definici√≥n a un perfil, por ejemplo puedes cambiar el valor de PATH para todos los usuarios del sistema, conect√°ndote como root y editando el archivo /etc/profile modificando la l√≠nea donde se define la variable PATH.

Si fuese necesario eliminar una variable se utilizar√≠a el comando **unset**.

El comando **alias** se utiliza para indicarle a la terminal de Linux que reemplace una cadena por otra al ejecutar comandos.

Es importante mencionar que los alias persisten solo durante la sesi√≥n actual. Se pueden cargar no obstante en el momento del inicio de sesi√≥n modificando el fichero bash_profile.

Al invocar el comando alias sin argumentos, se mostrar√°n todos los comandos con alias definidos actualmente.

Para crear un alias se usar√° de la siguiente forma:

    alias nombre = ‚Äúlista_comando_par√°metros‚Äù

## Editores de texto

Existen muchos **editores de texto** en Linux, aunque los m√°s conocidos son b√°sicamente:

- Nano
-   **Vi / Vim**
-   **Emacs**
-   **Gedit**

### nano

![](media/4b45f8b14c40d7d219676926d0faf4a6.jpeg)

Nano es sin ninguna duda el editor de texto en consola m√°s utilizado. La raz√≥n de esto es su simplicidad, facilidad de uso, y el hecho de que est√° preinstalado por defecto en muchas Linux conocidas.

Los comandos se completan con combinaciones de la tecla *Ctrl* y una letra que se muestra en la parte inferior.

![](media/7d9125391e73f6f5680d23eef08889b4.png)

### vi/vim

![Resultado de imagen de vim editor logo](media/2595b5dc236572f0dc04c5170d6f3592.png)

Vim es un editor mejorado del vetusto Vi. Es un editor de texto muy flexible, con el cual realizar cualquier tipo de operaci√≥n en los textos, aunque tiene una curva de aprendizaje moderada.

Suele ser la principal opci√≥n para desarrolladores y usuarios avanzados en Linux.

Sus propiedades son muchas y variadas. Permite usar expresiones regulares para reemplazar fragmentos de texto en un archivo y ofrece una manera f√°cil y √°gil de navegar entre l√≠neas, p√°rrafos y palabras, adem√°s incluye resaltado de texto, etc‚Ä¶.

![](media/3b8c8739d977f823afed58ba51088c86.jpeg)

### Emacs

![](media/28929c9a21b4e77c411bdc1f277b0d73.png)

Es otro de los editores en l√≠nea de comandos m√°s antiguo y vers√°til para sistemas

basados en Linux y UNIX, pero tambi√©n es el m√°s complejo.

Emacs proporciona un entorno integrado para diferentes tipos de tareas. Permite cambiar a modo trabajo similar a Vi / Vim.

![](media/463bc6f51aa72ceb63df83af3f93f0e1.jpeg)

### Gedit

![](media/13684fd01603a4f2955f5607bbe0ace4.jpeg)

Un cl√°sico y popular editor de textos sencillo pero potente para entornos gr√°ficos basados en Gnome o similares. Existen ports para otros SO como Windows o Mac.

Incluye herramientas para la edici√≥n de c√≥digo fuente y textos estructurados, como lenguajes de marcado.

![](media/17a620290daf02441cf11db0b537eba9.jpeg)

## Metacaracteres

El shell bash proporciona varios caracteres llamados **metacaracteres** (caracteres comod√≠n) que tienen un significado especial al usarlos en cualquier *script*, es decir, son como reservados por el propio sistema para realizar funciones especiales:

| **Metacar√°cter** | **Significado**                                                     |
|------------------|---------------------------------------------------------------------|
| ?                | Representa un √∫nico caracter                                        |
| \*               | Representa ning√∫n o cualquier car√°cter (incluido vac√≠o)             |
| [abc]            | Conjunto de caracteres individuales; ya sea '*a*'*,* '*b*'*,* '*c*' |
| [a-z]            | Rango de caracteres; de la letra 'a' a la 'z'                       |
| { , }            | Conjunto de patrones de caracteres separados por comas              |
| [! ]             | Negaci√≥n de un conjunto de caracteres (que no incluya)              |
| \|               | Alternativa entre dos expresiones                                   |
| \\               | Mostrar un metacaracter especial                                    |

A diferencia de los caracteres vistos en la consola CMD, los del terminal de Linux son mucho m√°s variados, complejos y potentes de utilizar.

Adem√°s de los metacaracteres, muchos comandos que veremos m√°s adelante permiten el uso de **expresiones regulares**. Las expresiones regulares se utilizan para describir patrones de texto.


## Operaciones generales

### Manejo de directorios/ficheros

Los comandos para **operaciones generales** de manejo de directorios y ficheros en consola son los siguientes:

| **Comando** | **Acci√≥n**                              | **Ejemplo**                |
|-------------|-----------------------------------------|----------------------------|
| **cp**      | copia archivos o directorios            | cp \*.txt correspondencia/ |
| **mv**      | mueve o renombra archivos o directorios | mv palabras.txt texto.txt  |
| **rm**      | borra archivos o directorios            | rm -R cosas/basurilla      |

```bash
#Borrar un fichero o directorio:
~$ rm fichero
#Renombrar un fichero:
~$ mv ficheroorig ficherofinal
#Mover de sitio un fichero:
~$ mv ficheroorig path/ficherofinal
#Copiar un fichero/directorio:
~$ cp dirorigen/ficheroorig dirfinal/ficherofinal
```

### Cambio de usuario

Cambiar de usuario en sistemas Linux y utilizar privilegios de administrador, conocido como **root**, es algo muy habitual. Para ello se utilizan los comandos su y sudo.

Para cambiar de usuario activo se utiliza el comando **su** *("***S***witch* **U***ser‚Äù)*

    ~$ su nombreusuario

-   **sudo** viene de "**s***witch* **u***ser* **do**" y permite a los usuarios ejecutar comandos que requieren privilegios de seguridad del **root**, de una manera segura.

    Por defecto Ubuntu trae desactivada la cuenta del "root", por seguridad. Para administrar el sistema existe un grupo de usuarios denominado "sudoers users" (administradores o admin), los cuales pueden obtener permisos de root, mediante la utilizaci√≥n de "sudo" lo que veremos en unidades posteriores.

        ~$ sudo comando

    Cuando necesitamos utilizar programas **en modo gr√°fico** (GUI) que requieran privilegios administrativos, se puede usar el comando **gksudo**


### Listado de directorios/ficheros

Para obtener la lista de los ficheros en el directorio actual se utiliza el comando **ls**:

    ~$ ls [directorio\|fichero]

Par√°metros:

    ls -l: Informaci√≥n detallada
    ls -a: Todos (incluidos ocultos)
    ls -t: Ordenar por fecha de modificaci√≥n
    ls ‚Äìr: Ordenaci√≥n inversa

### Mostrar el contenido de ficheros

Para mostrar el contenido de un fichero de texto se usa el comando **cat**.

Si queremos mostrar solamente las primeras l√≠neas de un fichero o las √∫ltimas utilizaremos los comandos **head** o **tail**

### Comando date

El comando **date** sirve para mostrar la fecha y la hora actual. Dicha salida puede formatearse con una secuencia de caracteres de control de formato precedidos por el signo + entre "". Los controles de formato comienzan con el % y se sustituyen por los caracteres de control de dicho formato de salida.

Listado de los caracteres de formato m√°s comunes:

- %d D√≠a del mes
- %H Hora (formato 24h)
- %m Mes
- %M Minuto
- %s Segundo
- %Y A√±o completo
- %u D√≠a de la semana

### Enlaces

Un **enlace** en Linux es un puente a un archivo o directorio perteneciente al sistema. Es una referencia que podemos poner en cualquier sitio que nos interese y que act√∫a como una especie **acceso directo o puntero** a cualquier otro.

![](media/93d40883117e27799f1ee5c7cce5c9a0.jpeg)

Existen dos tipos de **enlaces** con distinto comportamiento en Linux:

-   Enlaces blandos o simb√≥licos
-   Enlaces duros o f√≠sicos

#### Enlaces blandos o simb√≥licos

Los enlaces simb√≥licos permite crear un enlace a otro archivo. Parecido a los accesos directos en Windows. No debe confundirse con un lanzador de aplicaciones. Sirven para colocar en una carpeta el acceso a ficheros que est√°n en otros lugares.

Tambi√©n para directorios. Pueden apuntar a archivos de otra partici√≥n. Los enlaces blandos se crean mediante el comando **ln ‚Äìs**

    ~$ ln -s /usr/share/man/man3 mienlace 

La l√≠nea anterior crear√≠a este enlace, que hemos denominado mienlace.

El usuario s√≥lo deber√° escribir (desde su directorio home) cd mienlace y el sistema autom√°ticamente lo redirigir√≠a hacia/usr/share/man/man3/

#### Enlaces duros o f√≠sicos

Recordar que los sistemas de archivos usados por Linux identifican los archivos en el disco mediante un n√∫mero llamado *inodo*.

Un **enlace duro** consiste en asignar otro nombre en un directorio que apunta a un fichero o inodo existente. Los enlaces duros, asocian dos o m√°s ficheros compartiendo el mismo *inodo*. Esto hace que cada enlace duro sea una copia exacta del resto de ficheros asociados, tanto de datos como de permisos, propietario:

- Si se cambia el archivo, todos los enlaces duros ver√°n el cambio.
- Si se borra el fichero original la informaci√≥n no se pierde.
- S√≥lo pueden crearse enlaces duros entre archivos de la misma partici√≥n.

 Se crean mediante el comando **ln**:

    ~$ ln ficheroExistente enlace1.txt
    ~$ ln ficheroExistente enlace2.txt

![](media/3c692b7f6b3cb50103e938c4488da0b8.png)

Para conocer el n√∫mero de *inodo* correspondiente a un archivo usaremos **ls -li**

![](media/8d231b698143c43e57772ae7fa0fb1ad.jpeg)

### Ficheros ocultos

**Ocultar** archivos y directorios en Linux es una operaci√≥n relativamente sencilla.

La forma m√°s habitual de hacerlo consiste en colocar un punto al inicio del nombre del archivo o directorio.

Desde un terminal de consola proceder√≠amos de la siguiente forma:

    mv fichero.txt .fichero.txt

La segunda opci√≥n de ocultar archivos ser√≠a creando un archivo llamado *.hidden*. En este archivo colocaremos los nombres de todos los archivos y directorios que queramos ocultar.

### Buscar ficheros

El comando find en Linux se usa para buscar archivos y directorios en el sistema de archivos bas√°ndose en diferentes criterios, como nombre, fecha de modificaci√≥n, etc.
Su sintaxis es la siguiente:

    find [ruta] [opciones] [acci√≥n]

Par√°metros:
- ruta ‚Üí Directorio donde buscar (. para la actual, / para todo el sistema, etc.).
- opciones ‚Üí Criterios de b√∫squeda como nombre, tipo, tama√±o, permisos, etc.
- acci√≥n ‚Üí Qu√© hacer con los archivos encontrados (mostrar, eliminar, mover, etc.).

Buscar archivos por nombre en un directorio espec√≠fico:

    find /home/user -name "documento.txt"
    
Buscar archivos con extensi√≥n .log en cualquier subdirectorio:

    find /var/log -name "*.log"
    

## Gesti√≥n de paquetes de software

```note
Un sistema de gesti√≥n de paquetes es una colecci√≥n de herramientas propia de cada distribuci√≥n Linux que proporciona un m√©todo para la
instalaci√≥n, actualizaci√≥n y eliminaci√≥n de software para el SO.
```

El software es una de las grandes diferencias en Linux respecto Windows. A diferencia de lo que pasa en Windows u otros SO, en Linux se distribuye a trav√©s de un ‚Äúsistema de paquetes‚Äù que es donde se contienen los programas o utilidades. A estos paquetes est√°n vinculados **metadatos** que contienen informaci√≥n como una lista de dependencias necesarias para que el software funcione correctamente en cada distribuci√≥n en concreto.

Esos paquetes se centralizan en **repositorios**, ya sean locales (USB, DVD o disco duros) aunque generalmente desde **repositorios** en Internet.

![](media/127c95e0ec2a03c580ff1b0430af5406.png)

Los paquetes a su vez, tienen un formato concreto manejado por el gestor de paquetes, dependiendo de la familia de distribuci√≥n que estemos utilizando.

Los formatos de paquetes m√°s conocidos son:

-   **RPM**: paquetes que utiliza la distribuci√≥n Fedora/Red Hat (y derivadas). Se suelen manejar utilizando el comando *rpm*.
-   **DEB**: paquetes de Debian (los utilizados en Ubuntu), se suelen manejar con un conjunto de herramientas entre las que cabe mencionar *dpkg, apt-get y aptitude.*
-   **SNAP**: Es el nuevo tipo de paqueter√≠a autocontenida con todo lo necesario para instalar software. Es lo m√°s parecida a lo que conocemos en Windows, aunque es poco eficiente.
-   **Tar**, o bien los tgz (tambi√©n *tar.gz*): son puramente paquetes de ficheros unidos y comprimidos mediante *tar* y *gzip* (se usan los mismos para la descompresi√≥n). Estos paquetes no contienen dependencias y pueden instalarse en diferentes lugares sin ruta concreta.

### Repositorios

El **repositorio**, en cambio, es un sitio centralizado donde se almacena y mantiene informaci√≥n digital de los paquetes de software que utilice una distribuci√≥n en concreto. Cada distribuci√≥n tiene los suyos propios (entre ellos el OFICIAL) en los que est√°n almacenados los programas dise√±ados para esa distribuci√≥n.

Ubuntu utiliza paquetes Debian (DEB), dividiendo todo su software en cuatro secciones, llamadas **componentes**, para mostrar diferencias en licencias y la prioridad con la que se atienden los problemas que informen los usuarios:

-   Main
-   Restricted
-   Universe
-   Multiverse
-   Patrocinados\*

![](media/90026d912eb2232242a6c5162cd8cf18.png)


- **Repositorio Main**

    -   Contiene solamente los paquetes que cumplen los requisitos de la licencia de Ubuntu.
    -   Hay soporte disponible por parte del equipo.
    -   Est√°n pensados para que incluya todo lo necesario para la mayor√≠a de los sistemas Linux de uso general.
    -   Los paquetes de este componente poseen ayuda t√©cnica garantizada y mejoras de seguridad oportunas.
    -   Algunos paquetes que usan Main ser√≠an por ejemplo nano o Firefox.


- **Repositorio Restricted**

    -   Paquetes soportados por los desarrolladores de Ubuntu debido a su importancia pero que no est√° disponible bajo ning√∫n tipo de licencia libre para incluir en *main*.
    -   En este lugar se incluyen los paquetes como controladores **propietarios** de algunas tarjetas gr√°ficas (*ATI y NVIDIA*) u otro dispositivo hardware.

- **Repositorio Universe**

    -   Todo el software incluido en Universe es libre y de c√≥digo abierto.
    -   Es un repositorio de software que por motivos diversos no se incluyo en el repositorio ya que su mantenimiento y actualizaciones de seguridad no es tan riguroso como el de main.
    -   No hay garant√≠a de actualizaciones de seguridad por tanto.

- **Repositorio Multiverse**

    -   En el repositorio Multiverse, se puede encontrar generalmente software de c√≥digo abierto con dudas legales o con licencias dudosas.
    -   Tambi√©n incluye software de c√≥digo abierto con restricciones legales, por ejemplo, software de reproducci√≥n de audio y video que infringe las patentes.

### El gestor de paquetes de Ubuntu

```note
**Advanced Packaging Tool** (Herramienta Avanzada de Empaquetado), abreviado APT, es el sistema de gesti√≥n de paquetes creado por el proyecto Debian y usado en Ubuntu. 
```

El gestor **apt** naci√≥ en la distribuci√≥n Linux Debian en el a√±o 1998.

A partir de ese momento se convirti√≥ en parte importante de esta distro y derivadas como Ubuntu manejando sus paquetes con un grupo de programas.

Es bueno aclarar que apt son varios programas, cada uno con diferentes funciones aunque el que mas usaremos ser√° **apt** o **apt-get** en Ubuntu.

Tambi√©n existe un comando *apt-get* muy parecido a *apt*. La diferencia entre ambos es que apt es una versi√≥n reducida o m√°s espec√≠fica de las funciones m√°s utilizadas.

Los principales par√°metros de **apt** son los siguientes: sudo apt [par√°metro]

| **Par√°metro apt** | **Descripcion**                                                                                             |
|-------------------|-------------------------------------------------------------------------------------------------------------|
| apt **list**      | Muestra el listado completo de paquetes, dependiendo de los par√°metros que especifiquemos.                  |
| apt **search**    | Para buscar un paquete concreto.                                                                            |
| apt **update**    | Lo primero que hay que hacer es buscar actualizaciones de los paquetes que tenemos respecto al repositorio. |
| apt **upgrade**   | Para aplicar los cambios y actualizaciones del apt update.                                                  |
| apt **install**   | Para instalar cualquier aplicaci√≥n disponible conocido su nombre.                                           |
| apt **remove**    | desinstalar el programa o aplicaci√≥n indicado.                                                              |
| apt **remove**    | igual que remove, pero tambi√©n elimina los ficheros de configuraci√≥n que haya creado la aplicaci√≥n.         |

Para **buscar actualizaciones** en los paquetes del sistema usaremos *apt update*:

![apt update ejemplo](media/24ad78393e724a84ee1a77d0c63a7790.png)

Para aplicar las **Actualizaciones** a dichos paquetes usaremos *apt upgrade*:

![apt upgrade ejemplo](media/f6e0530dc0840c085a357463a817d248.jpeg)

Para **Instalaci√≥n** de un nuevo componente usaremos apt install:

![apt install ejemplo](media/2d46f7e9e8effaf8f466f6fd7edebb62.jpeg)

La gesti√≥n de repositorios con apt se puede llevar a cabo de la siguiente forma.

-   A√±adir repositorios *(/etc/apt/sources.list o /etc/apt/sources.list.d)*

        add-apt-repository ppa:Nombre_Repositorio.

-   Eliminar repositorios:

        add-apt-repository -r ppa:Nombre_Repositorio


Desde la interfaz de Ubuntu, podemos utilizar los or√≠genes de software para gestionar repositoriosconcretos, en vez de utilizar comandos.

![Origenes de Software de Ubuntu 20.04](media/6d1d98333c6d4d6083e440b0452703db.png)

## Empaquetado y compresi√≥n de archivos

El comando **tar** permite **empaquetar** varios archivos en uno solo, sin comprimirlos y es utilizado habitualmente en cualquier distribuci√≥n Linux.

Para **empaquetar** una carpeta (o directorio) con tar: 

    tar **-vcf** nombre_archivo.tar nombre_directorio
    tar ‚Äìvcf ficherospacked.tar /home/javier/images

Para **desempaquetar** un archivo con tar:

    tar **-vxf** mi_archivo.tar
    tar ‚Äìvxf ficherospacked.tar

Para ver el contenido de un tar:

    tar ‚Äìtvf ficherospacked.tar

Se puede utilizar los par√°metros *--apend* o *--delete* para agregar o quitar ficheros:

    tar ‚Äìf ficherospacked.tar --append nuevofichero.d

Si adem√°s de empaquetar/desempaquetar queremos **comprimir/descomprimir** y entonces habr√° que usar los comandos **tar** y **gzip**.

No confundir **gzip** con **zip**, el cual no es compatible. **gzip** s√≥lo comprime archivos, pero no los archiva. Debido a esto a menudo se usa junto con tar para archivar.

Para comprimir sin m√°s se usa gzip, dando como resultado el fichero llamado test.gz

    gzip test.docx

Para comprimir con tar:

    tar -cvzf empaquetado.tar.gz \*.md

Y para descomprimir:

    tar ‚Äìxvzf empaquetado.tar.gz \*.md

| **.tar (tar)**                 |                                          |         |             |
|--------------------------------|------------------------------------------|---------|-------------|
| Empaquetar                     | tar **vcf** archivo.tar /archivo/mayo/\* |         |             |
| Desempaquetar                  | tar                                      | **vxf** | archivo.tar |
| Ver el contenido (sin extraer) | tar                                      | vtf     | archivo.tar |

| **.tar.gz - .tar.z - .tgz (tar con gzip)** |                                          |
|--------------------------------------------|------------------------------------------|
| Empaquetar y comprimir                     | tar zvcf archivo.tar.gz /archivo/mayo/\* |
| Desempaquetar y descomprimir               | tar zvxf archivo.tar.gz                  |
| Ver el contenido (sin extraer)             | tar zvtf archivo.tar.gz                  |

| **.gz (gzip)** |                                                                          |
|----------------|--------------------------------------------------------------------------|
| Comprimir      | gzip -q archivo (El archivo lo comprime y lo renombra como "archivo.gz") |
| Descomprimir   | gzip -d archivo.gz (El archivo lo descomprime y lo deja como "archivo"   |
